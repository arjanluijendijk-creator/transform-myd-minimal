#!/usr/bin/env python3
"""
YAML Generator Script
====================

Generates YAML files based on data directory structure and Excel field definitions:
1. config/object_list.yaml - Overview of all objects and their tables
2. fields.yaml per table - Field definitions from Excel files
3. value_rules.yaml - Value rules for mandatory/operational/derived fields

Author: Generated for transform-myd-minimal
"""

import os
import sys
import yaml
import pandas as pd
from pathlib import Path
from datetime import datetime


def scan_data_structure(base_path):
    """Scan data/config/{object}/{variant} structure to find all objects and tables."""
    objects = {}
    config_path = base_path / "data" / "config"
    
    if not config_path.exists():
        print(f"Warning: {config_path} does not exist")
        return {}
    
    # Scan for objects and variants
    for object_dir in config_path.iterdir():
        if object_dir.is_dir() and not object_dir.name.startswith('.'):
            object_name = object_dir.name
            tables = []
            
            for variant_dir in object_dir.iterdir():
                if variant_dir.is_dir() and not variant_dir.name.startswith('.'):
                    tables.append(variant_dir.name)
            
            if tables:
                objects[object_name] = sorted(tables)
    
    return objects


def generate_object_list_yaml(base_path):
    """Generate config/object_list.yaml with overview of all objects and tables."""
    objects_structure = scan_data_structure(base_path)
    
    # Format for YAML output
    yaml_data = {
        'Objects': []
    }
    
    for object_name, tables in objects_structure.items():
        yaml_data['Objects'].append({
            'object': object_name,
            'tables': tables
        })
    
    # Write to file
    output_path = base_path / "data" / "config" / "object_list.yaml"
    output_path.parent.mkdir(parents=True, exist_ok=True)
    
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(f"# Generated by generate_yaml_files.py @ {datetime.now().strftime('%Y%m%d %H%M')}\n")
        f.write("# Overview of all objects and their tables\n\n")
        yaml.dump(yaml_data, f, default_flow_style=False, allow_unicode=True)
    
    print(f"Generated: {output_path}")
    return output_path


def read_excel_field_definitions(excel_path):
    """Read Excel file and extract field definitions."""
    try:
        df = pd.read_excel(excel_path)
        return df
    except FileNotFoundError:
        print(f"Warning: Excel file not found: {excel_path}")
        return None
    except Exception as e:
        print(f"Error reading Excel file {excel_path}: {e}")
        return None


def determine_field_type(field_data):
    """Determine field type based on field properties."""
    # Default type
    field_type = "string"
    
    # You can extend this logic based on field naming patterns or descriptions
    field_name = field_data.get('field_name', '').lower()
    field_desc = field_data.get('field_description', '').lower()
    
    if any(keyword in field_name for keyword in ['date', 'dat', 'time']):
        field_type = "date"
    elif any(keyword in field_name for keyword in ['amount', 'amt', 'value', 'val']):
        field_type = "decimal"
    elif any(keyword in field_name for keyword in ['count', 'number', 'num', 'id']):
        field_type = "integer"
    elif any(keyword in field_desc for keyword in ['boolean', 'flag', 'indicator']):
        field_type = "boolean"
    
    return field_type


def generate_fields_yaml(base_path, object_name, variant):
    """Generate fields.yaml for a specific table (object/variant combination)."""
    excel_filename = f"fields_{object_name}_{variant}.xlsx"
    excel_path = base_path / "data" / "02_fields" / excel_filename
    
    df = read_excel_field_definitions(excel_path)
    if df is None:
        return None
    
    # Filter for target fields (these are the output fields)
    target_fields = df[df['field'] == 'Target'].copy()
    
    # Generate fields YAML structure
    fields_data = {
        'table': f"{object_name}_{variant}",
        'fields': []
    }
    
    for _, row in target_fields.iterrows():
        field_info = {
            'name': row.get('field_name', ''),
            'description': row.get('field_description', ''),
            'type': determine_field_type(row),
            'required': bool(row.get('field_is_mandatory', False)),
            'key': bool(row.get('field_is_key', False))
        }
        fields_data['fields'].append(field_info)
    
    # Write to file
    output_path = base_path / "data" / "config" / object_name / variant / "fields.yaml"
    output_path.parent.mkdir(parents=True, exist_ok=True)
    
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(f"# Generated by generate_yaml_files.py @ {datetime.now().strftime('%Y%m%d %H%M')}\n")
        f.write(f"# Field definitions for {object_name}_{variant}\n")
        f.write(f"# Source: data/02_fields/{excel_filename}\n\n")
        yaml.dump(fields_data, f, default_flow_style=False, allow_unicode=True)
    
    print(f"Generated: {output_path}")
    return output_path


def is_operational_field(field_name, field_description):
    """Determine if a field is operational based on name/description patterns."""
    operational_patterns = [
        'flag', 'status', 'indicator', 'control', 'system', 'process',
        'update', 'created', 'modified', 'version', 'lock'
    ]
    
    field_text = f"{field_name} {field_description}".lower()
    return any(pattern in field_text for pattern in operational_patterns)


def is_derived_field(field_name, field_description):
    """Determine if a field is derived based on name/description patterns."""
    derived_patterns = [
        'calculated', 'computed', 'derived', 'total', 'sum', 'average',
        'balance', 'amount', 'percentage', 'ratio'
    ]
    
    field_text = f"{field_name} {field_description}".lower()
    return any(pattern in field_text for pattern in derived_patterns)


def generate_value_rules_yaml(base_path, object_name, variant):
    """Generate value_rules.yaml for a specific table."""
    excel_filename = f"fields_{object_name}_{variant}.xlsx"
    excel_path = base_path / "data" / "02_fields" / excel_filename
    
    df = read_excel_field_definitions(excel_path)
    if df is None:
        return None
    
    # Filter for target fields
    target_fields = df[df['field'] == 'Target'].copy()
    
    # Generate rules YAML structure
    rules_data = {
        'table': f"{object_name}_{variant}",
        'value_rules': []
    }
    
    for _, row in target_fields.iterrows():
        field_name = row.get('field_name', '')
        field_description = row.get('field_description', '')
        is_mandatory = bool(row.get('field_is_mandatory', False))
        
        rule_info = {
            'field': field_name,
            'description': field_description
        }
        
        # Determine rule type based on field properties
        if is_mandatory:
            rule_info['rule'] = 'required'
            rule_info['reason'] = 'Mandatory field as per data specification'
        elif is_operational_field(field_name, field_description):
            rule_info['rule'] = 'constant'
            rule_info['value'] = ' '  # Empty/blank default
            rule_info['reason'] = 'Operational field; no semantic source in source data'
        elif is_derived_field(field_name, field_description):
            rule_info['rule'] = 'derive'
            rule_info['reason'] = 'Derived field; requires business logic implementation'
        else:
            rule_info['rule'] = 'map'
            rule_info['reason'] = 'Direct mapping from source field'
        
        rules_data['value_rules'].append(rule_info)
    
    # Write to file
    output_path = base_path / "data" / "config" / object_name / variant / "value_rules.yaml"
    output_path.parent.mkdir(parents=True, exist_ok=True)
    
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(f"# Generated by generate_yaml_files.py @ {datetime.now().strftime('%Y%m%d %H%M')}\n")
        f.write(f"# Value rules for {object_name}_{variant}\n")
        f.write(f"# Rules: required, constant, derive, map\n")
        f.write(f"# Source: data/02_fields/{excel_filename}\n\n")
        yaml.dump(rules_data, f, default_flow_style=False, allow_unicode=True)
    
    print(f"Generated: {output_path}")
    return output_path


def main():
    """Main function to generate all YAML files."""
    base_path = Path.cwd()
    
    print("Starting YAML file generation...")
    print(f"Base path: {base_path}")
    
    # 1. Generate object_list.yaml
    print("\n1. Generating object_list.yaml...")
    generate_object_list_yaml(base_path)
    
    # 2. Generate fields.yaml and value_rules.yaml for each table
    print("\n2. Generating fields.yaml and value_rules.yaml for each table...")
    objects_structure = scan_data_structure(base_path)
    
    for object_name, variants in objects_structure.items():
        for variant in variants:
            print(f"\nProcessing {object_name}/{variant}...")
            
            # Generate fields.yaml
            generate_fields_yaml(base_path, object_name, variant)
            
            # Generate value_rules.yaml
            generate_value_rules_yaml(base_path, object_name, variant)
    
    print("\nYAML file generation completed!")


if __name__ == "__main__":
    main()